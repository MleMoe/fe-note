<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.37">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/logo.png"><title>关于证明我是一名 JS 程序员这件事（面试版） | MleMoe 前端笔记</title><meta name="description" content="Mia's fe-notes">
    <link rel="modulepreload" href="/assets/app.d1630e5f.js"><link rel="modulepreload" href="/assets/index.html.3a5601c6.js"><link rel="modulepreload" href="/assets/index.html.7d3801cb.js"><link rel="modulepreload" href="/assets/optimization.1dbe5af1.js">
    <link rel="stylesheet" href="/assets/style.0de41331.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/logo.png" alt="MleMoe 前端笔记"><span class="site-name can-hide">MleMoe 前端笔记</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/MleMoe/fe-note" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/MleMoe/fe-note" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">关于证明我是一名 JS 程序员这件事（面试版） <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#浏览器" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#输入-url-到页面呈现" class="router-link-active router-link-exact-active sidebar-item" aria-label="输入 url 到页面呈现"><!--[--><!--]--> 输入 url 到页面呈现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#渲染机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="渲染机制"><!--[--><!--]--> 渲染机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#重排与重绘" class="router-link-active router-link-exact-active sidebar-item" aria-label="重排与重绘"><!--[--><!--]--> 重排与重绘 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#js-引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="JS 引擎"><!--[--><!--]--> JS 引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#浏览器加载顺序" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器加载顺序"><!--[--><!--]--> 浏览器加载顺序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#跨域" class="router-link-active router-link-exact-active sidebar-item" aria-label="跨域"><!--[--><!--]--> 跨域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#事件循环" class="router-link-active router-link-exact-active sidebar-item" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#垃圾回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="垃圾回收"><!--[--><!--]--> 垃圾回收 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/basic/#ecmascript-基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="ECMAScript 基础"><!--[--><!--]--> ECMAScript 基础 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#前端模块化规范" class="router-link-active router-link-exact-active sidebar-item" aria-label="前端模块化规范"><!--[--><!--]--> 前端模块化规范 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#typescript" class="router-link-active router-link-exact-active sidebar-item" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#new-操作符原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="New 操作符原理"><!--[--><!--]--> New 操作符原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#闭包" class="router-link-active router-link-exact-active sidebar-item" aria-label="闭包"><!--[--><!--]--> 闭包 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="继承"><!--[--><!--]--> 继承 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#异步编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="异步编程"><!--[--><!--]--> 异步编程 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/basic/#样式" class="router-link-active router-link-exact-active sidebar-item" aria-label="样式"><!--[--><!--]--> 样式 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#bfc" class="router-link-active router-link-exact-active sidebar-item" aria-label="BFC"><!--[--><!--]--> BFC <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#移动端自适应的方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="移动端自适应的方式"><!--[--><!--]--> 移动端自适应的方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#css-预处理器" class="router-link-active router-link-exact-active sidebar-item" aria-label="CSS 预处理器"><!--[--><!--]--> CSS 预处理器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#css-后处理器" class="router-link-active router-link-exact-active sidebar-item" aria-label="CSS 后处理器"><!--[--><!--]--> CSS 后处理器 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/basic/#网络" class="router-link-active router-link-exact-active sidebar-item" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#前端安全问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="前端安全问题"><!--[--><!--]--> 前端安全问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#http" class="router-link-active router-link-exact-active sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/basic/#编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="编程"><!--[--><!--]--> 编程 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#手写-promise" class="router-link-active router-link-exact-active sidebar-item" aria-label="手写 Promise"><!--[--><!--]--> 手写 Promise <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#节流防抖" class="router-link-active router-link-exact-active sidebar-item" aria-label="节流防抖"><!--[--><!--]--> 节流防抖 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#列表-树" class="router-link-active router-link-exact-active sidebar-item" aria-label="列表 -&gt; 树"><!--[--><!--]--> 列表 -&gt; 树 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/basic/#前端工程化" class="router-link-active router-link-exact-active sidebar-item" aria-label="前端工程化"><!--[--><!--]--> 前端工程化 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#webpack" class="router-link-active router-link-exact-active sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#babel" class="router-link-active router-link-exact-active sidebar-item" aria-label="Babel"><!--[--><!--]--> Babel <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#grunt" class="router-link-active router-link-exact-active sidebar-item" aria-label="Grunt"><!--[--><!--]--> Grunt <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#glup" class="router-link-active router-link-exact-active sidebar-item" aria-label="Glup"><!--[--><!--]--> Glup <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#roolup" class="router-link-active router-link-exact-active sidebar-item" aria-label="Roolup"><!--[--><!--]--> Roolup <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#esbuild" class="router-link-active router-link-exact-active sidebar-item" aria-label="esbuild"><!--[--><!--]--> esbuild <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#vite" class="router-link-active router-link-exact-active sidebar-item" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/basic/#框架" class="router-link-active router-link-exact-active sidebar-item" aria-label="框架"><!--[--><!--]--> 框架 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/basic/#vue" class="router-link-active router-link-exact-active sidebar-item" aria-label="vue"><!--[--><!--]--> vue <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/basic/#react" class="router-link-active router-link-exact-active sidebar-item" aria-label="react"><!--[--><!--]--> react <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="关于证明我是一名-js-程序员这件事-面试版" tabindex="-1"><a class="header-anchor" href="#关于证明我是一名-js-程序员这件事-面试版" aria-hidden="true">#</a> 关于证明我是一名 JS 程序员这件事（面试版）</h1><h2 id="浏览器" tabindex="-1"><a class="header-anchor" href="#浏览器" aria-hidden="true">#</a> 浏览器</h2><p>浏览器是前端开发的主要运行环境。 主要功能为向服务器请求资源，并在窗口中展示，资源一般指 HTML 文档，或 PDF、图片及其它格式。</p><p>如下图，浏览器的主要组件包括：</p><ul><li>用户界面（User Interface），页面内容外的部分，包括地址栏、后退/前进按钮、书签目录等；</li><li>浏览器引擎（Browser engine），用来查询及操作渲染引擎的接口；</li><li><strong>渲染引擎</strong>（Rendering engine）：解析请求内容与显示页面；</li><li>网络（Networking）：用于网络调用；</li><li>用户界面后端（UI Backend）：浏览器的基本图形库，底层使用操作系统接口；</li><li><strong>JS 解释器</strong>(JavaScript interpreter) ：解释执行 JS 代码；</li><li>数据持久化（Data Persistence）：Cookie、Local Storage 等数据存储机制。</li></ul><div align="center"><img src="/images/basic/browser-structure.png" width="600"></div><h3 id="输入-url-到页面呈现" tabindex="-1"><a class="header-anchor" href="#输入-url-到页面呈现" aria-hidden="true">#</a> 输入 url 到页面呈现</h3><ul><li>将 url 解析成 ip 地址，先查找缓存，没有则进行 dns 解析，向域名服务器处获取 ip</li><li>建立 tcp 连接</li><li>若是 https 则有一个 ssl 验证的过程</li><li>发送 http 请求</li><li>收到服务器响应的资源文档</li><li>构建 dom 树和 cssom 树，布局，再渲染，合成图层再显示在屏幕上</li></ul><h3 id="渲染机制" tabindex="-1"><a class="header-anchor" href="#渲染机制" aria-hidden="true">#</a> 渲染机制</h3><p>浏览器的渲染引擎负责解析和显示请求的内容。</p><blockquote><p>常见的渲染引擎有：Webkit（Chrome、safari）、Trident（IE）、Gecko（Firefox）。移动端通常是 Webkit 或 Blink 内核，此两者对新特性的支持度较高。其中 Blink 基于 Webkit2 创建，Android 的 WebView 同样基于 Webkit2。</p></blockquote><p>渲染引擎主要工作是以 HTML/JavaScript/CSS 等文件作为输入，以可视化内容作为输出。关键渲染路径如下：</p><ul><li>解析 HTML 构造 <strong>DOM 树</strong></li><li>解析 CSS 构造 <strong>CSSOM 树</strong></li><li>两者合并生成<strong>渲染树</strong>；</li><li>布局</li><li>绘制</li></ul><div align="center"><img src="/images/basic/render-flow.png" width="660"></div><h3 id="重排与重绘" tabindex="-1"><a class="header-anchor" href="#重排与重绘" aria-hidden="true">#</a> 重排与重绘</h3><h4 id="概念介绍" tabindex="-1"><a class="header-anchor" href="#概念介绍" aria-hidden="true">#</a> 概念介绍</h4><ul><li>重绘（repaint）：外观有变化时，会导致重绘。相关的样式属性如 <code>color</code> <code>opacity</code> 等</li><li>回流/重排（reflow）：布局结构或节点内容变化时，会导致重排。相关的样式属性如 <code>height</code> <code>float</code> <code>position</code> 等</li></ul><blockquote><p>注意：重排一定会触发重绘，而重绘不一定会。重绘的开销较小，回流的代价较高 获取布局信息时，会导致重排。相关的方法属性如 <code>offsetTop</code> <code>getComputedStyle</code> 等</p></blockquote><h4 id="如何减少重排重绘" tabindex="-1"><a class="header-anchor" href="#如何减少重排重绘" aria-hidden="true">#</a> 如何减少重排重绘</h4><ol><li>对 DOM 进行<strong>批量写入和读取</strong>（通过虚拟 DOM 或者 DocumentFragment 实现）。</li><li>避免对样式频繁操作，了解常用样式属性触发 Layout / Paint / Composite 的机制，合理使用样式。</li><li>合理利用特殊样式属性（如 <code>transform: translateZ(0)</code> 或者 <code>will-change</code>），将渲染层提升为合成层，开启 GPU 加速，提高页面性能。</li><li>使用变量对布局信息（如 <code>clientTop</code>）进行缓存，避免因频繁读取布局信息而触发重排和重绘。</li></ol><h3 id="js-引擎" tabindex="-1"><a class="header-anchor" href="#js-引擎" aria-hidden="true">#</a> JS 引擎</h3><p>JS 引擎用于解析和执行 JavaScript 代码，chrome 的 JS 解释器是 C++编写的 V8，JS 在 v8 引擎中的执行过程如下图：</p><div align="center"><img src="/images/wasm/v8-js.png" width="600"></div><p>JavaScript 的解析过程简单来说就是：源码 --&gt; AST --&gt; 字节码 --&gt; 二进制代码</p><ul><li>解析器 Parser 把 JS 代码转化成抽象语法树 AST</li><li>解释器 Ignition 将 AST 转化成字节码 ByteCode</li><li>执行字节码及优化</li></ul><p>解释执行字节码时，标记重复执行的热点代码，将之发送给编译器 TurboFan，编译为更高效的机器码并储存起来。下次执行该段代码时，用机器码替代执行。 另外，当编译器判断一段代码不再为热点代码的时候，会把优化的机器码丢掉，然后继续由解释器执行。</p><div align="center"><img src="/images/wasm/optimization.png" width="600"></div><blockquote><p>但由于 JavaScript 为动态类型语言，变量上一秒可能是 Array，下一秒就变成了 Number。那么上一次引擎所做的优化，就失去了作用，需重新优化。这是 TypeScript 出现的背景之一。</p></blockquote><h3 id="浏览器加载顺序" tabindex="-1"><a class="header-anchor" href="#浏览器加载顺序" aria-hidden="true">#</a> 浏览器加载顺序</h3><p>常规网页加载流程如下：</p><ol><li>浏览器一边下载 HTML 网页，一边开始解析；</li><li>解析过程中，发现 <code>&lt;script&gt;</code> 标签，暂停解析，网页渲染的控制权转交给 JS 引擎；</li><li>如果 <code>&lt;script&gt;</code> 标签引用了外部脚本，就下载该脚本，否则就直接执行；</li><li>执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li></ol><blockquote><p>JS 的加载和执行会造成阻塞。 因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。 html 需要等 head 中所有的 js 和 css 加载完成后才会开始绘制，但是 html 不需要等待放在 body 最后的 js 下载执行就会开始绘。 因此 script 的位置很重要，需遵循以下两个原则：CSS 优先和 JS 置后（<code>&lt;body&gt;</code>内底部），且 JS 应尽量少影响 DOM 的构建</p></blockquote><p><code>&lt;script&gt;</code> 标签内可使用 <code>async</code> 和 <code>defer</code> 缓解阻塞，如图：</p><div align="center"><img src="/images/basic/script-execution.png"></div><p>从上图可知：</p><ul><li><code>defer</code> 和 <code>async</code> 在网络加载过程中都是异步执行；</li><li>两者的区别在于脚本加载完成之后何时执行。</li></ul><blockquote><p>如果存在多个有 <code>defer</code> 属性的脚本，按照加载顺序执行；</p><p><code>async</code> 无论声明顺序如何，只要加载完成就立刻执行，完全不考虑依赖关系。</p><p>在实际应用中，<code>defer</code> 是<strong>更适合的</strong>缓解阻塞的方案。</p></blockquote><h3 id="跨域" tabindex="-1"><a class="header-anchor" href="#跨域" aria-hidden="true">#</a> 跨域</h3><p>前置概念：</p><ul><li>源（origin）：协议（protocol）、域（domain）、端口（port）的组合</li><li>浏览器的同源策略：不同源的网站无法访问对方内容 <blockquote><p>在浏览器中，<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>等标签可加载跨域资源，不受同源策略限制。 但是通过 src 加载的资源，会限制 JS 权限，不能对源文件本身进行读写。</p></blockquote></li></ul><p>常用方法如下：</p><h4 id="_1-window-postmessage-属性和-message-事件" tabindex="-1"><a class="header-anchor" href="#_1-window-postmessage-属性和-message-事件" aria-hidden="true">#</a> 1. <code>window.postMessage</code> 属性和 <code>message</code> 事件</h4><p>用于跨域<strong>跨窗口</strong>消息传递，可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>页面与嵌套的 iframe 消息传递</li><li>多窗口之间消息传递、</li><li>上面三个问题的跨域数据传递</li></ul><p>其工作方式如下：</p><ul><li><p>当前窗口 发送消息</p><ul><li>otherWindow 为目标窗口的一个引用。比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是 window.frames</li><li>message 序列化的待发送消息</li><li>targetOrigin 目标域</li></ul></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>otherWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> targetOrigin<span class="token punctuation">,</span> <span class="token punctuation">[</span>transfer<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>目标窗口 接收消息</li></ul><p>如果指定的源匹配的话，那么当调用 <code>postMessage()</code> 方法的时候，目标窗口的 Window 对象会触发一个 <code>message</code> 事件</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 为 window 添加 message 事件监听获取消息</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&#39;message&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin
    <span class="token comment">// 通常，onmessage()事件处理程序应当首先检测其中的origin属性，忽略来自未知源的消息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">!==</span> <span class="token string">&#39;http://example.org:8080&#39;</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_2-cors-跨源资源共享-cross-origin-resource-sharing" tabindex="-1"><a class="header-anchor" href="#_2-cors-跨源资源共享-cross-origin-resource-sharing" aria-hidden="true">#</a> 2. CORS：跨源资源共享（Cross-Origin Resource Sharing）</h4><p>参考：<a href="https://zh.javascript.info/fetch-crossorigin" target="_blank" rel="noopener noreferrer">跨源请求<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h4 id="_3-服务器代理" tabindex="-1"><a class="header-anchor" href="#_3-服务器代理" aria-hidden="true">#</a> 3. 服务器代理</h4><p>启一个代理服务器，实现数据的转发。常用 nginx 服务器</p><h4 id="_4-script-脚本-jsonp-json-with-padding" tabindex="-1"><a class="header-anchor" href="#_4-script-脚本-jsonp-json-with-padding" aria-hidden="true">#</a> 4. script 脚本 + JSONP (JSON with padding)</h4><p>原因：使用 script 标签， script 可以执行任何域的 src 文件。 假设网站需要以这种方式从 <code>http://another.com</code> 网站获取数据，需要后端配合。流程如下：</p><ul><li><p>先声明一个<strong>全局函数</strong>来<strong>接收数据</strong>，例如 gotWeather</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">gotWeather</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> temperature<span class="token punctuation">,</span> humidity <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">temperature: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>temperature<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, humidity: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>humidity<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>然后创建一个<code>&lt;script&gt;</code>标签，将上述函数名作为 <code>src</code> 属性 <code>URL</code> 的 callback 参数</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;script&#39;</span><span class="token punctuation">)</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://another.com/weather.json?callback=gotWeather</span><span class="token template-punctuation string">`</span></span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>远程服务器 <code>another.com</code> 动态生成一个脚本，该脚本内容为：调用 <code>gotWeather</code> 函数，并将数据作为参数传入，由此获得数据</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">gotWeather</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">temperature</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>
  <span class="token literal-property property">humidity</span><span class="token operator">:</span> <span class="token number">78</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul><h3 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h3><blockquote><p>参考资料</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener noreferrer">并发模型与事件循环<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://juejin.cn/post/6979876135182008357" target="_blank" rel="noopener noreferrer">手摸手带你彻底掌握，任务队列、事件循环、宏任务、微任务<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></blockquote><div align="center"><img src="/images/basic/The_Javascript_Runtime_Environment_Example.svg"></div><blockquote><p>多个运行时通信方法：</p><p>一个 <code>web worker</code> 或者一个跨域的 <code>iframe</code> 都有自己的栈、堆和消息队列。 两个不同的运行时只能通过 <code>postMessage</code> 方法进行通信。如果另一个运行时侦听 <code>message</code> 事件，则此方法会向该运行时添加消息。</p></blockquote><p>浏览器的代码运行机制分为三个主要部分：</p><ul><li><p><strong>调用栈 Call Stack</strong>：存放代码执行期间的所有执行上下文（回调函数）</p></li><li><p>堆 Heap：存放变量的值，通常是非结构化对象</p></li><li><p><strong>消息队列 Queue</strong>：待处理消息/任务队列</p><blockquote><p>任务进入任务队列，会利用到浏览器的其他线程。 虽说 JS 是单线程语言，但是浏览器不是。浏览器不同的线程会对不同的事件进行处理，当对应事件可执行时，就将其放入任务队列。 浏览器线程有：</p><ul><li>js 引擎线程：用于解释执行 js 代码、用户输入、网络请求等；</li><li>GUI 渲染线程：绘制用户界面，与 JS 主线程互斥（因为 js 可以操作 DOM，进而会影响到 GUI 的渲染结果）；</li><li>http 异步网络请求线程：处理用户的 get、post 等请求，等返回结果后将回调函数推入到任务队列；</li><li>定时触发器线程：setInterval、setTimeout 等待时间结束后，会把执行函数推入任务队列中；</li><li>浏览器事件处理线程：将 click、mouse 等 UI 交互事件发生后，将要执行的回调函数放入到事件队列中。</li></ul></blockquote></li></ul><p>由于 JS 是单线程的（只有一个执行栈），若有一个任务需长久等待（如网络请求），就会造成阻塞。由于 JS 主线程和渲染渲染线程相互阻塞，那么也会造成浏览器假死。 于是需要有异步机制，这需要<strong>事件循环</strong>来做任务调度。事件循环就是一直监听并一个一个地执行消息队列中的任务</p><h4 id="同步与异步任务" tabindex="-1"><a class="header-anchor" href="#同步与异步任务" aria-hidden="true">#</a> 同步与异步任务</h4><p>JS 将所有执行任务分为了同步任务和异步任务。</p><ul><li>同步任务按照代码顺序和调用顺序，支持进入调用栈中并执行，执行结束后就移除调用栈。</li><li>异步任务依旧会进入调用栈中，然后发起调用，解释器会将其响应回调任务放入一个任务队列，紧接着调用栈会将这个任务移除。 当主线程清空后，即所有同步任务结束后，解释器会读取任务队列，并依次将已完成的异步任务加入调用栈中并执行。</li></ul><h4 id="宏任务与微任务" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务" aria-hidden="true">#</a> 宏任务与微任务</h4><p>在任务队列中，其实还分为<strong>宏任务队列（Task Queue）<strong>和 <strong>微任务队列（Microtask Queue）</strong>，对应的里面存放的就是</strong>宏任务</strong>和<strong>微任务</strong>。 <strong>宏任务和微任务都是异步任务</strong>。</p><ul><li>常见的宏任务：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node 环境)</li><li>常见的微任务：async/await（后）、Promise.then、Object.observe、MutaionObserver、process.nextTick(Node 环境)</li></ul><p>事件循环的具体流程如下：</p><ul><li>首次执行时，解释器会将整体代码 script 放入宏任务队列中，即第一个入队任务</li><li>执行宏任务队列中第一个入队的任务，放入调用栈，开始执行；</li><li>执行完该宏任务下所有同步任务后，执行中间记录的微任务直至微任务队列清空为止； <blockquote><p>执行微任务时，产生新的微任务也需添加到微任务队列中，也需一起清空；微任务队列没清空之前，是不会执行下一个宏任务的</p></blockquote></li><li>当微任务队列清空后，一个事件循环结束；接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。</li></ul><h4 id="测试题" tabindex="-1"><a class="header-anchor" href="#测试题" aria-hidden="true">#</a> 测试题</h4><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>

<span class="token comment">// 第一次执行 4 1 3 6 9</span>
<span class="token comment">// 微任务 2 7</span>
<span class="token comment">// 宏任务 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h3><p>垃圾回收的方法有：</p><ul><li><p>引用计数</p><p>当声明了一个变量并将某个对象赋予它时，这个对象的引用数加一，反之减一。</p><p>对引用数为 0 的变量清除。</p><blockquote><p>可以即刻回收垃圾，但是计数过程过于复杂，并且循环引用无法回收。</p></blockquote></li><li><p>标记清除</p><p>标记阶段，垃圾回收器由根对象开始遍历，所有根对象能访问到的对象会被标记为可到达对象。</p><p>清除阶段，对内存从头到尾线性遍历，没有标记的对象一律回收。</p><blockquote><p>此方法实现简单，但是会造成大量的内存碎片。</p></blockquote></li></ul><p>如何定位内存泄露：</p><p>内存泄漏是指不再使用的内存，没有被垃圾回收机制回收。</p><p>代码量较小时，开发者通常可以基于以下基本原则快速自查，除此之外，开发者可以借助外部工具（如 DevTools 的 Memory 面板）进行内存泄漏排查。</p><ol><li>是否滥用全局变量，没有手动回收。</li><li>是否没有正确销毁定时器、闭包。</li><li>是否没有正确监听事件和销毁事件。</li></ol><h2 id="ecmascript-基础" tabindex="-1"><a class="header-anchor" href="#ecmascript-基础" aria-hidden="true">#</a> ECMAScript 基础</h2><h3 id="前端模块化规范" tabindex="-1"><a class="header-anchor" href="#前端模块化规范" aria-hidden="true">#</a> 前端模块化规范</h3><blockquote><p>参考：<a href="https://febook.hzfe.org/awesome-interview/book1/js-module-specs" target="_blank" rel="noopener noreferrer">前端模块化规范<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h4 id="主要-js-模块化规范类型" tabindex="-1"><a class="header-anchor" href="#主要-js-模块化规范类型" aria-hidden="true">#</a> 主要 JS 模块化规范类型</h4><ol><li><p><strong>CommonJS</strong>: 主要是 <strong>Node</strong> 端使用，通过 <code>require</code> <strong>同步</strong>加载模块，<code>exports</code> 导出内容。</p><ul><li>优点：简单易用、可以在任意位置 require 模块、支持循环依赖</li><li>缺点：同步的加载方式不适用于浏览器端、浏览器端使用需要打包、难以支持模块静态分析</li></ul></li><li><p><strong>AMD</strong>: 主要是<strong>浏览器端</strong>使用，通过 <code>define</code> 定义模块和依赖，<code>require</code> 异步加载模块，推崇依赖前置。</p><ul><li>优点：异步加载、支持循环依赖、支持插件</li><li>缺点：语法相对复杂、依赖加载器、难以支持模块静态分析</li><li>具体实现：RequireJs</li></ul><blockquote><p>CMD: 和 AMD 比较类似，主要是浏览器端使用，通过 <code>require</code> 异步加载模块，<code>exports</code> 导出内容，推崇依赖就近。</p></blockquote></li><li><p><strong>UMD</strong>: 通用模块规范，是 CommonJS、AMD 两个规范的大<strong>融合</strong>，是<strong>跨平台</strong>的解决方案。</p><ul><li>优点：跨平台兼容</li><li>缺点：代码量稍大</li></ul><blockquote><p>UMD 加载模块的方式取决于所处的环境，Node.js 同步加载，浏览器端异步加载。</p></blockquote></li><li><p><strong>ESM</strong>: 官方模块化规范，现代浏览器原生支持，通过 <code>import</code> 加载模块，<code>export</code> 导出内容。</p><ul><li>优点：支持同步/异步加载、语法简单、支持模块静态分析、支持循环引用</li><li>缺点：可能存在兼容性问题</li></ul><blockquote><p>ESM 加载模块的方式同样取决于所处的环境，Node.js 同步加载，浏览器端异步加载。</p></blockquote></li></ol><h4 id="为什么需要模块化和模块化规范-​" tabindex="-1"><a class="header-anchor" href="#为什么需要模块化和模块化规范-​" aria-hidden="true">#</a> 为什么需要模块化和模块化规范 ​</h4><p>模块化可以解决代码之间的变量、函数、对象等命名的冲突/污染问题，良好的模块化设计可以降低代码之间的耦合关系，提高代码的可维护性、可扩展性以及复用性。</p><p>模块化规范的作用是为了规范 JavaScript 模块的定义和加载机制，以统一的方式导出和加载模块，降低学习使用成本，提高开发效率。</p><h4 id="tree-shaking​" tabindex="-1"><a class="header-anchor" href="#tree-shaking​" aria-hidden="true">#</a> Tree Shaking​</h4><p>Tree Shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）行为的术语。它依赖于 ES2015 中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。 Tree Shaking - MDN</p><p>简单来说，Tree Shaking 是一种依赖 ESM 模块静态分析实现的功能，它可以在编译时安全的移除代码中未使用的部分（webpack 5 对 CommonJS 也进行了支持，在此不详细展开）。</p><h3 id="typescript" tabindex="-1"><a class="header-anchor" href="#typescript" aria-hidden="true">#</a> TypeScript</h3><h3 id="new-操作符原理" tabindex="-1"><a class="header-anchor" href="#new-操作符原理" aria-hidden="true">#</a> New 操作符原理</h3><h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h3><blockquote><p><a href="https://febook.hzfe.org/awesome-interview/book1/js-closures" target="_blank" rel="noopener noreferrer">闭包的作用和原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>作用：能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局。</p><p>原理：基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外被访问到。</p><p>前置概念：</p><ul><li><p>作用域：用于确定在何处以及如何查找变量（标识符）的一套规则。</p></li><li><p>词法作用域：定义在词法阶段的作用域，由写代码时将代码和块作用域写在哪里来决定，因此用词法作用域处理代码是会保持作用域不变(大部分情况)。</p></li><li><p>块作用域：指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常用{}包裹）。常见的块级作用域有 with，try/catch，let，const 等。</p></li><li><p>函数作用域：属于这个函数的全部变量都可以在整个函数范围内使用及复用（包括嵌套作用域）。</p></li><li><p>作用域链：查找变量时，先从当前作用域开始查找，如果没有找到，就会到父级(词法层面上的父级)作用域中查找，一直找到全局作用域。作用域链正是包含这些作用域的列表。</p></li></ul><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h3><h3 id="异步编程" tabindex="-1"><a class="header-anchor" href="#异步编程" aria-hidden="true">#</a> 异步编程</h3><h2 id="样式" tabindex="-1"><a class="header-anchor" href="#样式" aria-hidden="true">#</a> 样式</h2><h3 id="bfc" tabindex="-1"><a class="header-anchor" href="#bfc" aria-hidden="true">#</a> BFC</h3><h4 id="bfc-是什么" tabindex="-1"><a class="header-anchor" href="#bfc-是什么" aria-hidden="true">#</a> BFC 是什么</h4><p>BFC 全称为 block formatting context，中文为“块级格式化上下文”。它是一个只有块级盒子参与的独立块级渲染区域，它规定了内部的块级盒子如何布局，且与区域外部无关。</p><h4 id="bfc-作用" tabindex="-1"><a class="header-anchor" href="#bfc-作用" aria-hidden="true">#</a> BFC 作用</h4><ol><li><p>修复浮动元素造成的高度塌陷问题</p></li><li><p>避免非期望的外边距折叠</p></li><li><p>实现灵活健壮的自适应布局</p></li></ol><h4 id="触发-bfc-的常见条件" tabindex="-1"><a class="header-anchor" href="#触发-bfc-的常见条件" aria-hidden="true">#</a> 触发 BFC 的常见条件</h4><ul><li><p><code>&lt;html&gt;</code> 根元素</p></li><li><p><code>float</code> 的值不为 <code>none</code></p></li><li><p><code>position</code> 的值不为 <code>relative</code> 或 <code>static</code></p></li><li><p><code>overflow</code> 的值不为 <code>visible</code> 或 <code>clip</code>（除了根元素）</p></li><li><p><code>display</code></p><ul><li><code>table-cell</code>，<code>table-caption</code>， <code>inline-block</code>，<code>flow-root</code>，<code>list-item</code>。</li><li><strong>flex 或 grid 直接子元素</strong> 即 <code>display</code> 的值为 <code>flex</code>/<code>inline-flex</code>/<code>grid</code>/<code>inline-grid</code> 的元素的直接子元素 <blockquote><p>该子元素 <code>display</code> 不为 <code>flex</code>，<code>grid</code>，或 <code>table</code></p></blockquote></li></ul></li><li><p><code>contain</code> 的值为 <code>layout</code>，<code>content</code>，<code>paint</code>，或 <code>strict</code> 中的任意一个</p></li><li><p><code>column-span</code> 设置为 <code>all</code> 的元素</p></li></ul><blockquote><p>提示：<code>display: flow-root</code>，<code>contain: layout</code> 等是无副作用的，可在不影响已有布局的情况下触发 BFC。</p></blockquote><h3 id="移动端自适应的方式" tabindex="-1"><a class="header-anchor" href="#移动端自适应的方式" aria-hidden="true">#</a> 移动端自适应的方式</h3><h3 id="css-预处理器" tabindex="-1"><a class="header-anchor" href="#css-预处理器" aria-hidden="true">#</a> CSS 预处理器</h3><h3 id="css-后处理器" tabindex="-1"><a class="header-anchor" href="#css-后处理器" aria-hidden="true">#</a> CSS 后处理器</h3><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h2><h3 id="前端安全问题" tabindex="-1"><a class="header-anchor" href="#前端安全问题" aria-hidden="true">#</a> 前端安全问题</h3><h4 id="xss-跨站脚本攻击" tabindex="-1"><a class="header-anchor" href="#xss-跨站脚本攻击" aria-hidden="true">#</a> XSS 跨站脚本攻击</h4><p>指攻击者在网页中注入恶意代码，在用户浏览网页的时候进行攻击。</p><p>类型：</p><ol><li><p>反射型（非持久性）</p><p><strong>原理</strong>：将攻击代码放在 url 地址的请求参数中，其他用户访问该恶意链接时，服务端在 URL 取出恶意代码后拼接至 HTML 中返回给用户浏览器。</p><p><strong>要点</strong>：</p><ul><li>通过 URL 插入恶意代码。</li><li>有服务端参与。</li><li>需要用户访问特定链接。</li></ul><p><strong>例子</strong>：</p><p>攻击者诱导被害者打开链接 <code>hzfe.org?name=&lt;script src=&quot;http://a.com/attack.js&quot;/&gt;</code>。</p><p>被攻击网站服务器收到请求后，未经处理直接将 URL 的 name 字段直接拼接至前端模板中，并返回数据。</p><p>被害者在不知情的情况下，执行了攻击者注入的脚本（可以通过这个获取对方的 Cookie 等）。</p></li><li><p>存储型（持久性）</p><p><strong>原理</strong>：攻击者将注入型脚本提交至被攻击网站数据库中，当其他用户浏览器请求数据时，注入脚本从服务器返回并执行。</p><p><strong>要点</strong>：</p><ul><li>恶意代码存储在目标网站服务器上。</li><li>有服务端参与。</li><li>只要用户访问被注入恶意脚本的页面时，就会被攻击。</li></ul><p><strong>例子</strong>：</p><p>攻击者在目标网站留言板中提交了 <code>&lt;script src=&quot;http://a.com/attack.js&quot;/&gt;</code>。</p><p>目标网站服务端未经转义存储了恶意代码，前端请求到数据后直接通过 innerHTML 渲染到页面中。</p><p>其他用户在访问该留言板时，会自动执行攻击者注入脚本。</p></li><li><p>DOM 型</p><p><strong>原理</strong>：攻击者通过在 URL 插入恶意代码，客户端脚本取出 URL 中的恶意代码并执行。</p><p><strong>要点</strong>：在客户端发生。</p><p><strong>例子</strong>：</p><p>攻击者诱导被害者打开链接 <code>hzfe.org?name=&lt;script src=&quot;http://a.com/attack.js&quot;/&gt;</code>。</p><p>被攻击网站前端取出 URL 的 name 字段后未经转义直接通过 innerHTML 渲染到页面中。</p><p>被害者在不知情的情况下，执行了攻击者注入的脚本。</p></li></ol><p>防范 XSS：​</p><ul><li>对于外部传入的内容进行充分转义。</li><li>开启 CSP（Content Security Policy，内容安全策略），规定客户端哪些外部资源可以加载和执行，降低 XSS 风险。</li><li>设置 Cookie <code>httpOnly</code> 属性，禁止 JS 读取 Cookie 防止被窃取。</li></ul><h4 id="csrf-跨站请求伪造" tabindex="-1"><a class="header-anchor" href="#csrf-跨站请求伪造" aria-hidden="true">#</a> CSRF 跨站请求伪造</h4><p>Cross Site Request Forgery，是指攻击者可以在用户不知情的情况下，窃用其身份在对应的网站进行操作</p><p>原理：攻击者诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的身份凭证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>要点：</p><ul><li>利用浏览器在发送 HTTP 请求时会自动带上 Cookie 的原理，冒用受害者身份请求。</li><li>攻击一般发生在第三方网站上。</li><li>攻击者只能“冒用”受害者的身份凭证，并不能获取。</li><li>跨站请求有多种方式，常见的有图片 URL、超链接、Form 提交等。</li></ul><p>例子：</p><p>攻击者在第三方网站上放置一个如下的 img</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://hzfe.org/article/delete<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>受害者访问该页面后（前提：受害者在 hzfe.org 登录过且产生了 Cookie 信息），浏览器会自动发起这个请求，hzfe.org 就会收到包含受害者身份凭证的一次跨域请求。</p><p>若目标网站没有任何防范措施，那攻击者就能冒充受害者完成这一次请求操作。</p><p>防范：</p><ol><li><p>使用 CSRF Token 验证用户身份</p><ul><li>原理：服务端生成 CSRF Token （通常存储在 Session 中），用户提交请求时携带上 Token，服务端验证 Token 是否有效。</li><li>优点：能比较有效的防御 CSRF （前提是没有 XSS 漏洞泄露 Token）。</li><li>缺点：大型网站中 Session 存储会增加服务器压力，且若使用分布式集群还需要一个公共存储空间存储 Token，否则可能用户请求到不同服务器上导致用户凭证失效；有一定的工作量。</li></ul></li><li><p>双重 Cookie 验证</p><ul><li>原 理：利用攻击者不能获取到 Cookie 的特点，在 URL 参数或者自定义请求头上带上 Cookie 数据，服务器再验证该数据是否与 Cookie 一致。</li><li>优点：无需使用 Session，不会给服务器压力。</li></ul></li><li><p>设置 Cookie 的 SameSite 属性可以用来限制第三方 Cookie 的使用，可选值有 Strict、Lax、None。</p><ul><li>Strict：完全禁止第三方 Cookie。</li><li>Lax：只允许链接、预加载请求和 GET 表单的场景下发送第三方 Cookie。</li><li>None：关闭 SameSite 属性。</li></ul></li><li><p>设置白名单，仅允许安全域名请求</p></li><li><p>增加验证码验证</p></li></ol><h4 id="中间人攻击-mitm" tabindex="-1"><a class="header-anchor" href="#中间人攻击-mitm" aria-hidden="true">#</a> 中间人攻击（MITM）</h4><p>是指攻击者与通讯的两端分别创建独立的联系，在通讯中充当一个中间人角色对数据进行监听、拦截甚至篡改。</p><p>成功的中间人攻击主要有两个不同的阶段：<strong>拦截和解密</strong>。</p><h5 id="拦截-​" tabindex="-1"><a class="header-anchor" href="#拦截-​" aria-hidden="true">#</a> 拦截 ​</h5><p>即攻击者需要用户数据在到达目标设备前拦截并通过攻击者的网络。分为被动攻击和主动攻击。</p><p>常见的被动攻击（也是最简单）的方法，攻击者向公众提供免费的恶意 WiFi 热点，一旦有受害者连接了该热点，攻击者就能完全了解其所有的在线数据交换。</p><p>常见的主动攻击有两种：</p><ul><li>ARP 欺骗： 攻击者利用 ARP 的漏洞，通过冒充网关或其他主机，使得到达网关或其他主机的流量通过攻击者主机进行转发。</li><li>DNS 欺骗： 攻击者冒充域名服务器，将受害者查询的 IP 地址转发到攻击者的 IP 地址。</li></ul><h5 id="解密-​" tabindex="-1"><a class="header-anchor" href="#解密-​" aria-hidden="true">#</a> 解密 ​</h5><p>拦截后，若连接是使用 HTTPS 协议即传递的数据用了 SSL / TLS 加密，这时还需要其他手段去解密用户数据。</p><ol><li><p>SSL 劫持（伪造证书）</p><p>攻击者在 TLS 握手期间拦截到服务器返回的公钥后，将服务器的公钥替换成自己的公钥并返回给客户端，这样攻击者就能用自己的私钥去解密用户数据，也可以用服务器公钥解密服务器数据。</p><p>因为是伪造的证书，所以客户端在校验证书过程中会提示证书错误，若用户仍选择继续操作，此时中间人便能获取与服务端的通信数据。</p></li><li><p>SSL 剥离</p><p>攻击者拦截到用户到服务器的请求后，攻击者继续和服务器保持 HTTPS 连接，并与用户降级为不安全的 HTTP 连接。</p><p>服务器可以通过开启 HSTS（HTTP Strict Transport Security）策略，告知浏览器必须使用 HTTPS 连接。但是有个缺点是用户首次访问时因还未收到 HSTS 响应头而不受保护。</p></li></ol><h5 id="中间人攻击防范-​" tabindex="-1"><a class="header-anchor" href="#中间人攻击防范-​" aria-hidden="true">#</a> 中间人攻击防范 ​</h5><p>对于开发者来说：</p><ul><li>支持 HTTPS。</li><li>开启 HSTS 策略。</li></ul><p>对于用户来说：</p><ul><li>尽可能使用 HTTPS 链接。</li><li>避免连接不知名的 WiFi 热点。</li><li>不忽略不安全的浏览器通知。</li><li>公共网络不进行涉及敏感信息的交互。</li><li>用可信的第三方 CA 厂商，不下载来源不明的证书。</li></ul><h3 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h3><h4 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h4><h4 id="缓存机制" tabindex="-1"><a class="header-anchor" href="#缓存机制" aria-hidden="true">#</a> 缓存机制</h4><h4 id="http-1-0、2-0" tabindex="-1"><a class="header-anchor" href="#http-1-0、2-0" aria-hidden="true">#</a> HTTP 1.0、2.0</h4><h2 id="编程" tabindex="-1"><a class="header-anchor" href="#编程" aria-hidden="true">#</a> 编程</h2><h3 id="手写-promise" tabindex="-1"><a class="header-anchor" href="#手写-promise" aria-hidden="true">#</a> 手写 Promise</h3><h3 id="节流防抖" tabindex="-1"><a class="header-anchor" href="#节流防抖" aria-hidden="true">#</a> 节流防抖</h3><h3 id="列表-树" tabindex="-1"><a class="header-anchor" href="#列表-树" aria-hidden="true">#</a> 列表 -&gt; 树</h3><h2 id="前端工程化" tabindex="-1"><a class="header-anchor" href="#前端工程化" aria-hidden="true">#</a> 前端工程化</h2><h3 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> Webpack</h3><h3 id="babel" tabindex="-1"><a class="header-anchor" href="#babel" aria-hidden="true">#</a> Babel</h3><h3 id="grunt" tabindex="-1"><a class="header-anchor" href="#grunt" aria-hidden="true">#</a> Grunt</h3><h3 id="glup" tabindex="-1"><a class="header-anchor" href="#glup" aria-hidden="true">#</a> Glup</h3><h3 id="roolup" tabindex="-1"><a class="header-anchor" href="#roolup" aria-hidden="true">#</a> Roolup</h3><h3 id="esbuild" tabindex="-1"><a class="header-anchor" href="#esbuild" aria-hidden="true">#</a> esbuild</h3><h3 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> vite</h3><h2 id="框架" tabindex="-1"><a class="header-anchor" href="#框架" aria-hidden="true">#</a> 框架</h2><h3 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> vue</h3><h4 id="双向绑定" tabindex="-1"><a class="header-anchor" href="#双向绑定" aria-hidden="true">#</a> 双向绑定</h4><p>Vue 通过 <code>v-model</code> 实现双向绑定。<code>v-model</code> 实际是 <code>v-bind:xxx</code> 和 <code>v-on:xxx</code> 的语法糖。当触发元素对应的事件（如 <code>input</code>、<code>change</code> 等）时更新数据（<code>ViewModel</code>），当数据（<code>ViewModel</code>）更新时同步更新到对应 <code>View</code> 上。</p><h4 id="mvvm-model-view-viewmodel" tabindex="-1"><a class="header-anchor" href="#mvvm-model-view-viewmodel" aria-hidden="true">#</a> MVVM（Model-View-ViewModel）</h4><p>MVVM 模式是一种软件架构模式，相比 MVC 模式多了一个 <code>ViewModel</code> 层。有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来。</p><ul><li><code>Model</code>：模型层，负责处理业务逻辑以及和服务器端进行交互。</li><li><code>View</code>：视图层，将数据通过 UI 展现出来。</li><li><code>ViewModel</code>：视图模型层，连接 <code>Model</code> 层和 <code>View</code> 层。</li></ul><h4 id="响应式更新机制" tabindex="-1"><a class="header-anchor" href="#响应式更新机制" aria-hidden="true">#</a> 响应式更新机制</h4><p>前置概念：</p><ul><li><p>响应式对象：Vue2 通过 <code>Object.defineProperty</code>，Vue3 通过 <code>Proxy</code> 来劫持 <code>state</code> 中各个属性的 <code>setter</code>、<code>getter</code>。 通过 <code>getter</code> 收集依赖。当 <code>state</code> 中的数据发生变动之后发布通知给<strong>订阅者</strong>更新数据。</p></li><li><p>实现模块：Dep（实现发布订阅模式的模块），Watcher（订阅更新和触发视图更新的模块）。</p></li></ul><p>Vue 内数据变化与发布更新的流程如图：</p><div align="center"><img src="/images/basic/vue-data-update.png" width="600"></div><ol><li><p>Vue3 通过 Proxy 来劫持 state 中各个属性的 getter、setter。 其中 getter 中主要是通过 Dep 收集依赖这个属性的订阅者，setter 中则是在属性变化后通知 Dep 收集到的订阅者，派发更新。</p></li><li><p>Vue 会在需要使用到属性的地方新建一个 Watcher 实例，watcher 实例化时会读取对应属性的内容，从而触发 getter，将 watcher 注册进 Dep 中。</p></li><li><p>state 属性更新时会触发属性的 setter，setter 中会触发 Dep 的更新，Dep 通知收集到的 watcher 更新，watcher 获取到更新的数据之后触发更新视图。</p></li></ol><h4 id="vue2-vue3-数据劫持差别" tabindex="-1"><a class="header-anchor" href="#vue2-vue3-数据劫持差别" aria-hidden="true">#</a> vue2 vue3 数据劫持差别</h4><p>Vue2 使用的 Object.defineProperty 并不能完全劫持所有数据的变化，以下是几种无法正常劫持的变化：</p><ul><li>无法劫持新创建的属性，为了解决这个问题，Vue2 提供了 <code>Vue.set</code> 以创建新属性。</li><li>无法劫持数组的变化，为了解决这个问题，Vue2 对数组原生方法进行了劫持。</li><li>无法劫持利用索引修改数组元素，这个问题同样可以用 <code>Vue.set</code> 解决。</li></ul><p>​Vue3 使用的是 Proxy。Proxy 可以创建一个对象的代理，从而实现对这个对象基本操作的拦截和自定义。</p><h4 id="computed-和-watch-的区别" tabindex="-1"><a class="header-anchor" href="#computed-和-watch-的区别" aria-hidden="true">#</a> computed 和 watch 的区别</h4><p>computed 是模板表达式的声明式描述，会创建新的响应式数据。 而 watch 是响应式数据的自定义侦听器，用于响应数据的变化。</p><p>除此之外，computed 还具有可缓存，可依赖多个属性，getter 函数无副作用等特点。</p><p>watch 则更适用于异步或开销大的操作。</p><p>在了解 Vue 数据双向绑定的基础上，computed 等同于为属性设置 getter 函数（也可设置 setter）。</p><p>而 watch 等同于为属性的 setter 设置回调函数、监听深度 deep 及响应速度 immediate。</p><h3 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> react</h3><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/MleMoe/fe-note/edit/main/docs/basic/index.md" rel="noopener noreferrer" target="_blank" aria-label="帮助改善此页面"><!--[--><!--]--> 帮助改善此页面 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: i@mle.moe">MleMoe</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.d1630e5f.js" defer></script>
  </body>
</html>
