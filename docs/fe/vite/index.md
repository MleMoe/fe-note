# vite

## 来由

本来用过 vite，也看过不少介绍 vite 的帖子，但也就是一知半解。

正好去参加了 GMTC2021，尤雨溪尤大（vite 作者，其实不用介绍）在这会上给 vite 打了广告，噢，是作了分享。

于是就借着这个机会梳理一下 vite。

Vite 是什么？

Vite 由两个部分组成：

- No-Bundle 开发服务器
  源文件无需打包，直接以原生 ES Module 的形式加载
- 生产构建
  基于 Rollup 预先配置好的，针对生产环境高度优化的打包命令

为什么用 Vite？

- 快
- 合理的默认配置
- 灵活可扩展

Vite 的设计基于两个新趋势

- 现代 JS 支持广泛铺开
  - ES Modules 已经 92.83% 的全球浏览器支持率
  - 微软推 Edge，想要干掉 IE11
- 新一代的用原生编译语言写的 JS 编译器，两者都比基于 JS 的编译工具快一个数量级
  - 基于 Go 的 esbuild
  - 基于 Rust 的 SWC

原生 ESM 开发服务器的优势

- 不需要打包源码
- 自然按需处理
- 可直接利用浏览器缓存
- 可以实现更简单搞笑的热更新（HMR）

原生 ESM 服务器的技术挑战

HTTP 请求开销，加载大量的小模块=大量的兵法 HTTP 请求=慢。像 lodash-es 包含超过 700 个内部模块

如何减少 HTTP 请求开销？

1. 用 esbuild 进行依赖预打包
   保证一个依赖最多对应一个 HTTP 请求，同时处理 CommonJS 转 ESM 的兼容

2. 利用 HTTP Header 缓存依赖
   对预打包过的依赖的请求会带有 `?v=xxxxx`的指纹
   直接上强缓存`Cache-Control: mac-age=31536000, immutable`
   除非版本变化，否则不会再产生 HTTP 请求

3. 优化源文件请求
   使用协商缓存策略。源文件返回的 header 带有 etag，服务器会保存每个文件的更新状态，没有改动的文件直接返回 `304 Not Modified`

整体的性能取舍

- 服务器启动：极大加快
- 第一溪页面加载会稍慢（视加载页面用到的源文件数量而定）
- 启动后全页面刷新速度不变
- 热更新极大加快

进一步优化的空间

- 针对源文件的文件系统缓存，以加快热启动的首次页面加载
- 用原生模块替换现有的模块改写链路，目前使用的是 acorn + magic-string

生产构建

为什么生产还是要打包？
不打包的部署模式会导致大量的级联 HTTp 请求，对缓存策略也有复杂的要求，目前来说依然不如打包的部署策略。

为什么使用 Rollup 打包？

Roolup 是一个为 ES module 而生的打包工具，并且有成熟的 tree-shaking 实现
针对应用打包的场景比 esbuild 成熟很多。esbuild 比较擅长库打包。而 Rollup 对代码分割和相应的优化处理提供了更深入的控制。

采用 Rollup 让 Vite 能够做到下面这些，采用 esbuild 就很难

- 自动 CSS 代码分割
- 对异步懒加载请求的自动优化
- 手动的代码分割控制

缺点是 Rollup 打包速度比 esbuild 慢，可是打包只是整个构建的一个部分而已，而且使用频率很低

合理的默认配置
开箱即用的工具
重复的配置=>约定

Vite 的哲学是：

- 针对 90% 的主流用户需求进行优化
- 大部分进阶需求通过插件支持
- 长尾特殊需求就让其它专用工具去做吧

进阶用户：插件系统
SSR Module Loader
